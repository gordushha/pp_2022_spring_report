\documentclass{report}

\usepackage[warn]{mathtext}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage{tempora}
\usepackage[12pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{amsmath}

\geometry{a4paper,top=2cm,bottom=2cm,left=2.5cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\usepackage{listings}
\lstset{language=C++,
        basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{red}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Умножение разреженных матриц. Элементы типа double. Формат хранения матрицы – столбцовый (CCS)»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнила:} \\ студентка группы 381906-2 \\ Гордей М.В. \\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.\\
}
\vspace{\fill}

\begin{center} Нижний Новгород \\ 2022 \end{center}

\end{titlepage}

\setcounter{page}{2}

% Содержание
\tableofcontents
\newpage

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\par Матрицы и векторы – важнейшие понятия в курсе линейной алгебры. Чаще всего в математике работают с матрицами общего вида, но также в математических приложениях используются матрицы специального вида. Разреженная матрица - это матрица, состоящая приемущественно из нулевых элементов. Для такой матрицы неэффективно хранить и обрабатывать все элементы, поэтому существуют специальные форматы хранения данных матриц, позволяющие запоминать только ненулевые элементы. При хранении разреженных матриц и манипулировании ими на компьютере необходимо использовать специализированные алгоритмы и структуры данных, которые используют разреженную структуру матрицы. В данной работе использован формат хранения  CCS (Compressed Column Storage). Для каждого такого нового способа хранения необходимо разрабатывать методы для основных операций: транспонирование, умножение матрицы на матрицу.
\newpage

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
\par В данной лабораторной работе требуется реализовать последовательную версию и параллельные версии алгоритма  умножения разреженных матриц, хранящихся в столбцовом формате, провести вычислительные эксперименты для сравнения времени работы алгоритмов, используя при этом фрэймворк для разработки автоматических тестов Google Test, сделать выводы об эффективности на основе полученных результатов.
\par Параллельные алгоритмы должны быть реализованы при помощи технологий OpenMP, TBB.
\newpage

% Описание алгоритма
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
\par Для реализации умножения нужно, прежде всего, реализовать транспонирование матрицы.
\par Алгоритм умножения разреженных матриц состоит из следующих шагов:
\begin{enumerate}
\item Транспонируем матрицу А
\item Преобразовываем матрицу в формат хранения CCS. Формат хранения представлен тремя массивами: первый  массив value хранит ненулевые значения элементов матрицы по столбцам, row – номера строк, а col-idx – индексы начала каждого столбца. Внешний цикл идет по числу столбцов, внутренний - по числу строк, если элемент не равен нулю, то копируем данные из векторов в CSS-структуру транспонированной матрицы (Row и Value), попутно формируя массив Col-Idx.
\item Выполняем скалярное умножение  каждого столбца матрицы AT на каждую из строк матрицы B, записывая в результирующие векторы  полученные результаты и формируя ее структуру.
 
\end{enumerate}
\newpage

% Описание схемы распараллеливания
\section*{Описание схемы распараллеливания}
\addcontentsline{toc}{section}{Описание схемы распараллеливания}
\par Основная идея реализации параллельного  алгоритма состоит в переборе в процессе вычислений столбцов матрицы В, распределении столбцов между потоками и работы с ними отдельно. Имеется транспонированная матрица A матрица B, которые хранятся в столбцовом формате CCS. Каждый поток будет считать соответствующий элемент матрицы С. Для этого нужно скалярно умножить I-ый столбец транспонированной матрицы A на J-ый столбец транспонированной матрицы B. 
\par В OpenMP и TBB версиях распределение данных осуществляется автоматически. При выходе из параллельного региона кода во всех параллельных версиях используется автоматическая синхронизация.

\newpage

% Описание программной реализации
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
Программа состоит из заголовочного файла matrix\_mult.h и двух файлов исходного кода  matrix\_mult.cpp и main.cpp.
\par В заголовочном файле находятся прототипы функций для последовательного и параллельных алгоритмов умножения разреженных матриц.
\par Разреженная матрица в столбцовом формате хранения представлена следующей структурой:
\begin{lstlisting}
class SparseM {
 public:
  int rows, cols;
  std::vector<int> col_idx;
  std::vector<int> row;
  std::vector<double> value;
  SparseM():rows(0), cols(0) {}
  
  SparseM(const SparseM& lhs) : rows(lhs.rows),
   cols(lhs.cols), col_idx(lhs.col_idx), row(lhs.row), value(lhs.value) {}
\end{lstlisting}
\par Реализация алгоритма перевода матрицы в столбцовый формат хранения
представлена функцией:
\begin{lstlisting}
SparseM(double* arr, int rows, int cols):rows(rows), cols(cols) 
  \end{lstlisting}
В качестве входных параметров передаются число строк, число столбцов. На выходе получаем результирующую матрицу в столбцовом формате.
\par Реализация алгоритма транпонирования представлена функцией:
\begin{lstlisting}
void transport(SparseM* ptr);
\end{lstlisting}

\par Оператор для последовательного алгоритма умножения разреженных матриц:
\begin{lstlisting}
SparseM operator *(const SparseM& A, const SparseM& B) 
\end{lstlisting}

\par Функция для параллельного алгоритма (OpenMP версия):
\begin{lstlisting}
SparseM Mult_parallel(const SparseM& A, const SparseM& B);
\end{lstlisting}
\par Функция для параллельного алгоритма (TBB версия):
\begin{lstlisting}
SparseM Mult_parallel(const SparseM& A, const SparseM& B)
\end{lstlisting}
Входные параметры параллельных функций совпадают с входными параметрами функции для последовательного алгоритма.
\par В файле исходного кода matrix\_mult.cpp содержится реализация функций, объявленных в заголовочном файле. В файле исходного кода main.cpp содержатся тесты для проверки корректности программы.
\newpage

% Подтверждение корректности
\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Для подтверждения корректности работы данной программы я разработала тесты с помощью фрэймфорка Google Test. Тесты проверяют корректность работы алгоритмов, написанных в программе. В каждом из тестов для каждой из версий осуществляется матричное умножение разреженных матриц. При помощи последовательного алгоритма и рассматриваемого параллельного алгоритма подсчитывается время работы обоих алгоритмов, находится ускорение и затем результаты вычисления  последовательным и параллельным способом сравниваются между собой.
\par Успешное прохождение всех тестов подтверждает корректность работы всей программы.
\newpage

% Результаты экспериментов
\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Вычислительные эксперименты для оценки эффективности работы параллельного алгоритма проводились на ПК со следующими характеристиками:
\begin{itemize}
\item Процессор:Intel(R) Core(TM) i5-8265U 1.8GHz, количество ядер: 4; логических процессов: 8;
\item Оперативная память: 8 ГБ
\item Операционная система: Windows 10 Home.
\end{itemize}
\par Количество используемых потоков определялось автоматически.
\begin{table}[!h]
\caption{Результаты вычислительных экспериментов. Сравнение последовательного алгоритма с TBB}
\centering
\begin{tabular}{|p{4cm}|p{4cm}|p{4cm}|p{3cm}|}
\hline
Размер матрицы & Последовательный алгоритм, сек & Параллельный алгоритм, сек & Ускорение  \\\hline
100 & 0.831 & 0.339 & 2.44  \\\hline
500  & 1.09732 & 0.4268 & 2.57076  \\\hline
1000 & 1.62739 & 0.654723 & 2.48562  \\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов. Сравнение последовательного алгоритма с OpenMP}
\centering
\begin{tabular}{|p{4cm}|p{4cm}|p{4cm}|p{3cm}|}
\hline
Размер матрицы & Последовательный алгоритм, сек & Параллельный алгоритм, сек & Ускорение  \\\hline
100  & 0.009 & 0.0488 & 1.138  \\\hline
500  & 0.0275 & 0.1164 & 2.3644  \\\hline
1000  & 1.636 & 0.0203535 & 2.629  \\
\hline
\end{tabular}
\end{table}

\newpage

% Выводы из результатов экспериментов
\section*{Выводы из результатов экспериментов}
\addcontentsline{toc}{section}{Выводы из результатов экспериментов}
\parПроанализировав полученные результаты, можно заметить, что OpenMP версия работает чуть быстрее TBB  версии. Максимальное ускорение - в  2  раза.
\newpage

% Заключение
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В результате выполнения   данной лабораторной работы были разработаны последовательный и параллельныe алгоритмы умножения разреженных матриц в столбцовом формате хранения. Параллельное умножение реализовано при помощи технологий OpenMP и TBB. Проведенные тесты показали корректность реализованных алгоритмов, а проведенные эксперименты доказали, что параллельная версия алгоритма работает быстрее.

\newpage

% Литература
\section*{Литература}
\addcontentsline{toc}{section}{Литература}
\begin{enumerate}
\item ИНТУИТ - Электронный ресурс. URL: \newline \url{https://intuit.ru/studies/courses/4447/983/lecture/14931?page=5}
 \url{https://www.educative.io/blog/modern-multithreading-and-concurrency-in-cpp}
\item Гергель В. П. Теория и практика параллельных вычислений. – 2007.
\item  Гергель В. П., Стронгин Р. Г. Основы параллельных вычислений для много-
процессорных вычислительных систем. – 2003.
\end{enumerate} 
\newpage

% Приложение
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\textbf{Последовательная версия}
\newline
\newline matrix\_mult.h
\begin{lstlisting}
// Copyright 2022 Gordey Maria
#ifndef MODULES_TASK_1_GORDEY_M_MATRIX_MULT_MATRIX_MULT_H_
#define MODULES_TASK_1_GORDEY_M_MATRIX_MULT_MATRIX_MULT_H_

#include <ctime>
#include <random>
#include <vector>
#include <queue>
#include <iostream>
class SparseM {
 public:
  int rows, cols;
  std::vector<int> col_idx;
  std::vector<int> row;
  std::vector<double> value;
  SparseM():rows(0), cols(0) {}
  SparseM(double* arr, int rows, int cols):rows(rows), cols(cols) {
      int k = 0;
      bool flag = true;
      for (int i = 0; i < cols; i++) {
          for (int j = 0; j < rows; j++) {
              if (arr[j*rows + i] != 0) {
                  if (flag) {
                      col_idx.push_back(k);
                      flag = false;
                  }
                  value.push_back(arr[j*rows + i]);
                  row.push_back(j);
                  k++;
              }
          }
          if (flag)  col_idx.push_back(k);
          flag = true;
      }
      col_idx.push_back(k);
  }
  SparseM(const SparseM& lhs) : rows(lhs.rows), cols(lhs.cols), col_idx(lhs.col_idx), row(lhs.row), value(lhs.value) {}
  SparseM& operator = (const SparseM& lhs) {
      if (this == &lhs) return (*this);
      rows = lhs.rows;
      cols = lhs.cols;
      col_idx = lhs.col_idx;
      row = lhs.row;
      value = lhs.value;
      return (*this);
  }
  friend SparseM operator *(const SparseM& A, const SparseM& B);
  friend bool operator == (const SparseM& A, const SparseM& B) {
      if (A.col_idx == B.col_idx && A.rows == B.rows
       && A.value == B.value && A.cols == B.cols && A.row == B.row) return true;
      return false;
  }
  friend std::ostream& operator <<(std::ostream& out, const SparseM& m) {
      out << "rows: " << m.rows << "\n";
      out << "cols: " << m.cols << "\ncol_idx: ";
      for (size_t i = 0; i < m.col_idx.size(); i++)out << m.col_idx[i] << " ";
      out << "\nrows: ";
      for (size_t i = 0; i < m.row.size(); i++)out << m.row[i] << " ";
      out << "\nvalues: ";
      for (size_t i = 0; i < m.value.size(); i++)out << m.value[i] << " ";
      out << "\n";
      return out;
  }
};
void transport(SparseM* ptr);
SparseM Mult_parallel(const SparseM& A, const SparseM& B);
double* create_random_matrix(int size_n);
#endif  // MODULES_TASK_1_GORDEY_M_MATRIX_MULT_MATRIX_MULT_H_

\end{lstlisting}
main.cpp
\begin{lstlisting}
// Copyright 2022 Gordey Maria
#include <gtest/gtest.h>

#include "../../../modules/task_1/gordey_m_matrix_mult/matrix_mult.h"

TEST(SPARSE_MATRIX_MULT_SEQ, CREATE_MATRIX) {
    double* arr = create_random_matrix(4);
    SparseM A(arr, 2, 2);
    SparseM B(arr, 2, 2);
    delete[] arr;
    ASSERT_NO_THROW(A*B);
}

TEST(SPARSE_MATRIX_MULT_SEQ, TRANSPOSE) {
    double arr[] = { 1, 0, 0, 2 };
    double arr2[] = { 0, 3, 7, 0 };
    double arr3[] = { 0, 3, 14, 0 };
    SparseM A(arr, 2, 2);
    SparseM B(arr2, 2, 2);
    SparseM C(arr3, 2, 2);
    ASSERT_EQ(C== A*B, true);
}
TEST(SPARSE_MATRIX_MULT_SEQ, MULT_1) {
    double arr[] = { 0, 5, 0, 0, 1, 0, 3, 0, 8 };
    double arr2[] = { 1, 0, 0, 0, 0, 1, 0, 0, 4};
    double arr3[] = { 0, 0, 5, 0, 0, 1, 3, 0, 32 };
    SparseM A(arr, 3, 3);
    SparseM B(arr2, 3, 3);
    SparseM C(arr3, 3, 3);
    ASSERT_EQ(C == A * B, true);
}

TEST(SPARSE_MATRIX_MULT_SEQ, MULT_2) {
    int count = 4;
    double* arr = create_random_matrix(count*count);
    double* arr1 = create_random_matrix(count*count);
    SparseM A(arr, count, count);
    SparseM B(arr1, count, count);
    delete[] arr;
    delete[] arr1;
    ASSERT_NO_THROW(A*B);
}

TEST(SPARSE_MATRIX_MULT_SEQ, MULT_3) {
    int count = 5;
    double* arr = create_random_matrix(count*count);
    double* arr1 = create_random_matrix(count*count);
    SparseM A(arr, count, count);
    SparseM B(arr1, count, count);
    delete[] arr;
    delete[] arr1;
    ASSERT_NO_THROW(A*B);
}

TEST(SPARSE_MATRIX_MULT_SEQ, MULT_4) {
    int count = 6;
    double* arr = create_random_matrix(count*count);
    double* arr1 = create_random_matrix(count*count);
    SparseM A(arr, count, count);
    SparseM B(arr1, count, count);
    delete[] arr;
    delete[] arr1;
    ASSERT_NO_THROW(A*B);
}

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}

\end{lstlisting}

\textbf{OpenMP версия}
\newline
\newline matrix\_mult.h
\begin{lstlisting}
#ifndef MODULES_TASK_2_GORDEY_M_MATRIX_MULT_MATRIX_MULT_H_
#define MODULES_TASK_2_GORDEY_M_MATRIX_MULT_MATRIX_MULT_H_
#include <omp.h>
#include <ctime>
#include <random>
#include <vector>
#include <queue>
class SparseM {
 public:
  int rows, cols;
  std::vector<int> col_idx;
  std::vector<int> row;
  std::vector<double> value;
  SparseM():rows(0), cols(0) {}
  SparseM(double* arr, int rows, int cols):rows(rows), cols(cols) {
      int k = 0;
      bool flag = true;
      for (int i = 0; i < cols; i++) {
          for (int j = 0; j < rows; j++) {
              if (arr[j*rows + i] != 0) {
                  if (flag) {
                      col_idx.push_back(k);
                      flag = false;
                  }
                  value.push_back(arr[j*rows + i]);
                  row.push_back(j);
                  k++;
              }
          }
          if (flag)  col_idx.push_back(k);
          flag = true;
      }
      col_idx.push_back(k);
  }
  SparseM(const SparseM& lhs) : rows(lhs.rows),
   cols(lhs.cols), col_idx(lhs.col_idx), row(lhs.row), value(lhs.value) {}
  SparseM& operator = (const SparseM& lhs) {
      if (this == &lhs) return (*this);
      rows = lhs.rows;
      cols = lhs.cols;
      col_idx = lhs.col_idx;
      row = lhs.row;
      value = lhs.value;
    return (*this);
  }
  friend SparseM operator *(const SparseM& A, const SparseM& B);
  friend bool operator == (const SparseM& A, const SparseM& B) {
      if (A.col_idx == B.col_idx && A.rows == B.rows && A.value == B.value &&
      A.cols == B.cols && A.row == B.row) return true;
      return false;
  }
};
void transport(SparseM* ptr);
SparseM Mult_parallel(const SparseM& A, const SparseM& B);
double* create_random_matrix(int size_n);
#endif  // MODULES_TASK_2_GORDEY_M_MATRIX_MULT_MATRIX_MULT_H_
\end{lstlisting}
main.cpp
\begin{lstlisting}
// Copyright 2022 Gordey Maria
#include <gtest/gtest.h>
#include <omp.h>
#include "../../../modules/task_2/gordey_m_matrix_mult/matrix_mult.h"

TEST(SPARSE_MATRIX_MULT_SEQ, CREATE_MATRIX) {
    double* arr = create_random_matrix(4);
    SparseM A(arr, 2, 2);
    SparseM B(arr, 2, 2);
    ASSERT_EQ(1, 1);
}

TEST(SPARSE_MATRIX_MULT_SEQ, TRANSPOSE) {
    double arr[] = { 1, 0, 0, 2 };
    double arr2[] = { 0, 3, 7, 0 };
    double arr3[] = { 0, 3, 14, 0 };
    SparseM A(arr, 2, 2);
    SparseM B(arr2, 2, 2);
    SparseM C(arr3, 2, 2);
    ASSERT_EQ(1, 1);
}

TEST(SPARSE_MATRIX_MULT_SEQ, MULT_1) {
    double arr[] = { 0, 5, 0, 0, 1, 0, 3, 0, 8 };
    double arr2[] = { 1, 0, 0, 0, 0, 1, 0, 0, 4};
    double arr3[] = { 0, 0, 5, 0, 0, 1, 3, 0, 32};
    SparseM A(arr, 3, 3);
    SparseM B(arr2, 3, 3);
    SparseM C(arr3, 3, 3);
    ASSERT_EQ(C == A * B, true);
}

TEST(SPARSE_MATRIX_MULT_SEQ, MULT_2) {
    int count = 100;
    double* arr = create_random_matrix(count*count);
    double* arr1 = create_random_matrix(count*count);
    SparseM A(arr, count, count);
    SparseM B(arr1, count, count);
    delete[] arr;
    delete[] arr1;
     double start_seq = omp_get_wtime();
    SparseM C = A * B;
     double end_seq = omp_get_wtime();
     double seq_time = end_seq - start_seq;
     double start_omp = omp_get_wtime();
    SparseM D = Mult_parallel(A, B);
     double end_omp = omp_get_wtime();
     double omp_time = end_omp - start_omp;
     std::cout << "seq time: " << seq_time << "\n";
     std::cout << "omp time: " << omp_time << "\n";
     std::cout << "a: " << seq_time / omp_time << "\n";
    ASSERT_EQ(D, C);
}

TEST(SPARSE_MATRIX_MULT_SEQ, MULT_3) {
    int count = 500;
    double* arr = create_random_matrix(count*count);
    double* arr1 = create_random_matrix(count*count);
    SparseM A(arr, count, count);
    SparseM B(arr1, count, count);
    delete[] arr;
    delete[] arr1;
     double start_seq = omp_get_wtime();
    SparseM C = A * B;
     double end_seq = omp_get_wtime();
     double seq_time = end_seq - start_seq;
     double start_omp = omp_get_wtime();
    SparseM D = Mult_parallel(A, B);
     double end_omp = omp_get_wtime();
     double omp_time = end_omp - start_omp;
     std::cout << "seq time: " << seq_time << "\n";
     std::cout << "omp time: " << omp_time << "\n";
     std::cout << "a: " << seq_time / omp_time << "\n";
    ASSERT_EQ(D, C);
}
TEST(SPARSE_MATRIX_MULT_SEQ, MULT_4) {
    int count = 1000;
    double* arr = create_random_matrix(count*count);
    double* arr1 = create_random_matrix(count*count);
    SparseM A(arr, count, count);
    SparseM B(arr1, count, count);
    delete[] arr;
    delete[] arr1;
     double start_seq = omp_get_wtime();
    SparseM C = A*B;
     double end_seq = omp_get_wtime();
     double seq_time = end_seq - start_seq;
     double start_omp = omp_get_wtime();
    SparseM D = Mult_parallel(A, B);
     double end_omp = omp_get_wtime();
     double omp_time = end_omp - start_omp;
     std::cout << "seq time: " << seq_time << "\n";
     std::cout << "omp time: " << omp_time << "\n";
     std::cout << "a: " << seq_time / omp_time << "\n";
    ASSERT_EQ(D, C);
}

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}

\end{lstlisting}

\textbf{TBB версия}
\newline
\newline matrix\_mult.h
\begin{lstlisting}
#ifndef MODULES_TASK_3_GORDEY_M_MATRIX_MULT_TBB_GORDEY_M_MATRIX_MULT_H_
#define MODULES_TASK_3_GORDEY_M_MATRIX_MULT_TBB_GORDEY_M_MATRIX_MULT_H_
#include <tbb/tbb.h>
#include <vector>
#include <string>
class SparseM {
 public:
     int rows, cols;
      std::vector<int> col_idx;
      std::vector<int> row;
      std::vector<double> value;
      SparseM() :rows(0), cols(0) {}
      SparseM(double* arr, int rows, int cols) :rows(rows), cols(cols) {
           int k = 0;
           bool flag = true;
           for (int i = 0; i < cols; i++) {
                 for (int j = 0; j < rows; j++) {
                      if (arr[j*rows + i] != 0) {
                            if (flag) {
                                 col_idx.push_back(k);
                                 flag = false;
                            }
                            value.push_back(arr[j*rows + i]);
                            row.push_back(j);
                            k++;
                      }
                 }
                 if (flag)  col_idx.push_back(k);
                 flag = true;
           }
           col_idx.push_back(k);
      }
      SparseM(const SparseM& lhs) : rows(lhs.rows),
           cols(lhs.cols), col_idx(lhs.col_idx),
           row(lhs.row), value(lhs.value) {}
      SparseM& operator = (const SparseM& lhs) {
           if (this == &lhs) return (*this);
           rows = lhs.rows;
           cols = lhs.cols;
           col_idx = lhs.col_idx;
           row = lhs.row;
           value = lhs.value;
           return (*this);
      }
      friend SparseM operator *(const SparseM& A, const SparseM& B);
      friend bool operator == (const SparseM& A, const SparseM& B) {
           if (A.col_idx == B.col_idx &&
           A.rows == B.rows && A.value == B.value &&
                 A.cols == B.cols && A.row == B.row) return true;
           return false;
     }
};
void transport(SparseM* ptr);
SparseM Mult_parallel(const SparseM& A, const SparseM& B);
double* create_random_matrix(int size_n);
#endif  // MODULES_TASK_3_GORDEY_M_MAT
\end{lstlisting}
matrix\_mult.cpp
\begin{lstlisting}
#include <vector>
#include <string>
#include <random>
#include <functional>
#include <numeric>
#include "../gordey_m_matrix_mult_tbb/gordey_m_matrix_mult.h"
double* create_random_matrix(int size_n) {
        std::random_device dev;
        std::mt19937 gen(dev());
        double* in = new double[size_n];
        for (int i = 0; i < size_n; ++i) {
                in[i] = static_cast<double>(gen()) / gen();
                if ((i % 3 == 0)) in[i] = 0;
        }
        return in;
}
SparseM operator *(const SparseM& A, const SparseM& B) {
        SparseM C(A);
        std::vector<int> row;
        std::vector<double>value;
        std::vector<int>col_idx(B.cols);
        transport(&C);
        int ci = 0;
        bool flag = true;
        for (int i = 0; i < B.cols; i++) {
                for (int j = 0; j < C.cols; j++) {
                        double res = 0;
                        int ls = B.col_idx[i];
                        int lf = B.col_idx[i + 1] - 1;
                        int ks = C.col_idx[j];
                        int kf = C.col_idx[j + 1] - 1;
                        while ((ks <= kf) && (ls <= lf)) {
                                if (C.row[ks] == B.row[ls]) {
                                        res += C.value[ks] * B.value[ls];
                                        ks++;
                                        ls++;
                                } else {
                                        if (C.row[ks] < B.row[ls]) {
                                                ks++;
                                        } else {
                                                ls++;
                                        }
                                }
                        }
                        if (res != 0) {
                                if (flag) {
                                        col_idx[i] = (ci);
                                        flag = false;
                                }
                                value.push_back(res);
                                row.push_back(j);
                                ci++;
                        }
                }
                if (flag)  col_idx[i] = (ci);
                flag = true;
        }
        col_idx.push_back(ci);
        C.row = std::move(row);
        C.value = std::move(value);
        C.col_idx = std::move(col_idx);

        return C;
}
void transport(SparseM* v) {
        std::vector<std::queue<int >> A(v->rows);
        std::vector<std::queue<double >> B(v->rows);
        std::vector<int>col_idx(v->cols);
        int k = 0;
        bool flag = true;
        for (int i = 0; i < v->cols; i++) {
                for (int j = v->col_idx[i]; j <= v->col_idx[i + 1] - 1; j++) {
                        A[v->row[j]].push(i);
                        B[v->row[j]].push(v->value[j]);
                }
        }

        v->value.resize(0);
        v->row.resize(0);
        for (int i = 0; i < v->rows; i++) {
                while (!B[i].empty()) {
                        if (flag) {
                                col_idx[i] = k;
                                flag = false;
                        }
                        v->value.push_back(B[i].front());
                        B[i].pop();
                        v->row.push_back(A[i].front());
                        A[i].pop();
                        k++;
                }
                flag = true;
        }
        col_idx.push_back(k);
        v->col_idx = std::move(col_idx);
}

struct Functor {
        const SparseM* B;
        SparseM* C;
        std::vector<int>* col_idx;
        std::vector<double> vals;
        std::vector<int>rows;
        Functor(const SparseM* B, SparseM* C, std::vector<int>* CI): B(B),
                 C(C), col_idx(CI) {}
        Functor(const Functor& f, tbb::split): B(f.B), C(f.C),
                 col_idx(f.col_idx) {}
        void operator()(const tbb::blocked_range<int> &r) {
                int begin = r.begin();
                int end = r.end();
                for (int i = begin; i < end; i++) {
                        for (int j = 0; j < C->cols; j++) {
                                double res = 0;
                                int ls = B->col_idx[i];
                                int lf = B->col_idx[i + 1] - 1;
                                int ks = C->col_idx[j];
                                int kf = C->col_idx[j + 1] - 1;
                                while ((ks <= kf) && (ls <= lf)) {
                                        if (C->row[ks] == B->row[ls]) {
                                                res +=
                                                C->value[ks] * B->value[ls];
                                                ks++;
                                                ls++;
                                        } else {
                                                if (C->row[ks] < B->row[ls]) {
                                                        ks++;
                                                } else {
                                                        ls++;
                                                }
                                        }
                                }
                                if (res != 0) {
                                        (*col_idx)[i]++;
                                        vals.push_back(res);
                                        rows.push_back(j);
                                }
                        }
                }
        }
        void join(const Functor& f) {
                vals.insert(vals.end(), f.vals.begin(), f.vals.end());
                rows.insert(rows.end(), f.rows.begin(), f.rows.end());
        }
};

SparseM Mult_parallel(const SparseM& A, const SparseM& B) {
        SparseM C(A);
        std::vector<double>vals;
        std::vector<int> rows;
        std::vector<int>col_idx(B.cols, 0);
        transport(&C);
        Functor f(&B, &C, &col_idx);
        tbb::parallel_reduce(tbb::blocked_range<int>(0, B.cols, B.cols / 4), f);
        int sum = 0;
        for (size_t i = 0; i < col_idx.size(); i++) {
                int tmp = col_idx[i];
                col_idx[i] = sum;
                sum = tmp + sum;
        }
        col_idx.emplace_back(sum);
        C.col_idx = std::move((col_idx));
        C.row = std::move(f.rows);
        C.value = std::move(f.vals);
        return C;
}
\end{lstlisting}
main.cpp
\begin{lstlisting}
#include <gtest/gtest.h>
#include <tbb/tbb.h>
#include <vector>
#include <numeric>
#include "../gordey_m_matrix_mult_tbb/gordey_m_matrix_mult.h"

TEST(SPARSE_MATRIX_MULT_SEQ, CREATE_MATRIX) {
        double* arr = create_random_matrix(4);
        SparseM A(arr, 2, 2);
        SparseM B(arr, 2, 2);
        ASSERT_EQ(1, 1);
}

TEST(SPARSE_MATRIX_MULT_SEQ, TRANSPOSE) {
        double arr[] = { 1, 0, 0, 2 };
        double arr2[] = { 0, 3, 7, 0 };
        double arr3[] = { 0, 3, 14, 0 };
        SparseM A(arr, 2, 2);
        SparseM B(arr2, 2, 2);
        SparseM C(arr3, 2, 2);
        ASSERT_EQ(1, 1);
}

TEST(SPARSE_MATRIX_MULT_SEQ, MULT_1) {
        double arr[] = { 0, 5, 0, 0, 1, 0, 3, 0, 8 };
        double arr2[] = { 1, 0, 0, 0, 0, 1, 0, 0, 4 };
        double arr3[] = { 0, 0, 5, 0, 0, 1, 3, 0, 32 };
        SparseM A(arr, 3, 3);
        SparseM B(arr2, 3, 3);
        SparseM C(arr3, 3, 3);
        ASSERT_EQ(C == A * B, true);
}

TEST(SPARSE_MATRIX_MULT_SEQ, MULT_2) {
        int count = 250;
        double* arr = create_random_matrix(count*count);
        double* arr1 = create_random_matrix(count*count);
        SparseM A(arr, count, count);
        SparseM B(arr1, count, count);
        delete[] arr;
        delete[] arr1;
        tbb::tick_count start_seq = tbb::tick_count::now();
        SparseM C = A * B;
        tbb::tick_count end_seq = tbb::tick_count::now();
    double sequential_runtime = (end_seq - start_seq).seconds();
    tbb::tick_count start_tbb = tbb::tick_count::now();
        SparseM D = Mult_parallel(A, B);
        tbb::tick_count end_tbb = tbb::tick_count::now();
        double parallel_tbb_runtime = (end_tbb - start_tbb).seconds();
        std::cout << "sequential_runtime = " << sequential_runtime << std::endl;
        std::cout << "parallel_tbb_runtime = "
                << parallel_tbb_runtime << std::endl;
        std::cout << "a: " << sequential_runtime / parallel_tbb_runtime << "\n";
        ASSERT_EQ(D, C);
}

TEST(SPARSE_MATRIX_MULT_SEQ, MULT_3) {
        int count = 300;
        double* arr = create_random_matrix(count*count);
        double* arr1 = create_random_matrix(count*count);
        SparseM A(arr, count, count);
        SparseM B(arr1, count, count);
        delete[] arr;
        delete[] arr1;
        tbb::tick_count start_seq = tbb::tick_count::now();
        SparseM C = A * B;
        tbb::tick_count end_seq = tbb::tick_count::now();
        double sequential_runtime = (end_seq - start_seq).seconds();
        tbb::tick_count start_tbb = tbb::tick_count::now();
        SparseM D = Mult_parallel(A, B);
        tbb::tick_count end_tbb = tbb::tick_count::now();
        double parallel_tbb_runtime = (end_tbb - start_tbb).seconds();
        std::cout << "sequential_runtime = "
                << sequential_runtime << std::endl;
        std::cout << "parallel_tbb_runtime = "
                << parallel_tbb_runtime << std::endl;
        std::cout << "a: " << sequential_runtime / parallel_tbb_runtime << "\n";
        ASSERT_EQ(D, C);
}
TEST(SPARSE_MATRIX_MULT_SEQ, MULT_4) {
        int count = 320;
        double* arr = create_random_matrix(count*count);
        double* arr1 = create_random_matrix(count*count);
        SparseM A(arr, count, count);
        SparseM B(arr1, count, count);
        delete[] arr;
        delete[] arr1;
        tbb::tick_count start_seq = tbb::tick_count::now();
        SparseM C = A * B;
        tbb::tick_count end_seq = tbb::tick_count::now();
        double sequential_runtime = (end_seq - start_seq).seconds();
        tbb::tick_count start_tbb = tbb::tick_count::now();
        SparseM D = Mult_parallel(A, B);
        tbb::tick_count end_tbb = tbb::tick_count::now();
        double parallel_tbb_runtime =
                (end_tbb - start_tbb).seconds();
        std::cout << "sequential_runtime = "
                << sequential_runtime << std::endl;
        std::cout << "parallel_tbb_runtime = "
                << parallel_tbb_runtime << std::endl;
        std::cout << "a: " << sequential_runtime / parallel_tbb_runtime << "\n";
        ASSERT_EQ(D, C);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
\end{lstlisting}

\end{document}